.so header
.tl /SIGNAL(3S)/Kreider OS-9 C Library/SIGNAL(3S)/
.sh NAME
.bb
signal - catch or ignore interrupts
.eb
.sh SYNOPSIS
.bb
#include <signal.h>
.sp
(*signal(interrupt, address))()
(*address)();
.eb
.sh DESCRIPTION
.db
This call is a comprehensive method of catching or ignoring signals sent to
the current process.  Notice that
.bo
KILL
does the sending of signals and
.bo
SIGNAL
does the catching.
.sp
Normally, a signal sent to a process causes it to terminate with the status
of the signal.  If, in advance of the signal, this system call is used,
the program has the choise of ignoring the signal or designating a function
to be executed when the signal is received.  Different functions may be
designated for different signals.
.sp
The values for
.ul
address
have the following meanings:
.bb
0 = reset to the default, i.e., abort when received
1 = ignore - this applies until reset to another value

Otherwise: taken to be the address of a C function which
is to be executed upon receipt of the signal.
.eb
If the latter case is chosen, when the signal is received by the process the
.ul
address
is reset to 0, the default, before the function is executed.  This means that
is the next signal received should be caught then another call to
.bo
SIGNAL
must be made immediately.  This is normally the first action taken by the
.bo
INTERRUPT
function.  The function may access the signal number which caused its
execution by looking at its argument.  On completion fo this function the
program resumes execution at the point where it was interrupted by the signal.
.ed
.sh EXAMPLE
.db
Suppose a program needs to create a temporary file which should be deleted
before exiting.  The body of the program might contain fragments like this:
.bb
pn = creat("temp",3);
signal(2,intrupt);
signal(3,intrupt);
write(pn,string,count);
close(pn);
unlink("temp");
exit(0);
.eb
The call to
.ul
signal()
will insure that if a keyboard or quit signal is received then the function
.ul
intrupt()
will be executed and this might written as:
.bb
intrupt(sig)
{
    close(pn);
    unlink("temp");
    exit(sig);
}
.eb
In this case, as the function will be exiting before another signal is
receive, it is unnecessary to call
.ul
signal()
again to reset its pointer.
Note that either the function
.ul
intrupt()
should appear in the source code before the call to
.ul
signal(),
or it should be pre-declared.
.sp
The signals used by OS-9 are define in the header file
.bo
SIGNAL.H
as follows:
.bb
/* OS-9 Signals
.sp
#define SIGKILL 0
#define SIGWAKE 1
#define SIGQUIT 2
#define SIGINT  3
.sp
/* special addresses */
.sp
#define SIG_DFL 0
#define SIG_IGN 1
.eb
Please note that there is another method of trapping signals, namely
.ul
intercept().
However, since
.ul
signal()
and
.ul
intercept()
are mutually incompatible, calls to both of them must not appear in the
same program.  The linker will prevent the creation of an executable program
in which both are called by aborting with an
.ul
entry name clash
error for
.ul
_sigint.
.ed
.sh SEE ALSO
.bb
intercept(), kill(), OS-9 Shell command "kill"
.eb
