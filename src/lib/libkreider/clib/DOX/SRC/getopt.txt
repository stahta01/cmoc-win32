.so header
.tl /GETOPT(3C)/Kreider OS-9 C Library/GETOPT(3C)/
.sh NAME
.bb
getopt - Get an option letter from argument vector
.eb
.sh SYNOPSIS
.bb
int getopt (argc, argv, optstring)
int argc;
char **argv, *optstring;
.sp
extern char *optarg;
extern int optind, opterr;
.eb
.sh DESCRIPTION
.db
.bo
GETOPT
returns the next option letter in
.ul
argv
that matches a letter in
.ul
optstring.  Optstring
is a string of recognized option letters; if a letter
is followed by a colon, the option is expected to have an argument that
may or may not be separated from it by white space.
.ul
Optarg
is set to point to the start of the option argument on return from
.bo
GETOPT.
.PP
.bo
GETOPT
places in
.ul
optind
the
.ul
argv
index of the next argument to be
processed. Because
.ul
optind
is external, it is normally initialized to zero
automatically before the first call to
.bo
GETOPT.
.PP
When all options have been processed (i.e., up to the first non-option
argument),
.bo
GETOPT
returns
.ul
EOF.
The special option -- may be used to
delimit the end of the options;
.ul
EOF
will be returned, and -- will be
skipped.
.ed
.sh DIAGNOSTICS
.db
.bo
GETOPT
prints an error message on the stderr path and returns a question mark
(?) when it encounters an option letter not included in
.ul
optstring.
This error message may be disabled by setting
.ul
opterr
to a non-zero value.
.ed
.sh EXAMPLE
.db
The following code fragment shows how one might process the arguments for a
command that can take the mutually exclusive options a and b, and the
options f and o, both of which require arguments:
.bb
main (argc, argv)
int argc;
char **argv;
{
.in +5
int c;
extern char *optarg;
extern int optind;
\&.
\&.
\&.
\&.
while ((c = getopt(argc, argv, "abf:o:")) != EOF)
.in +5
switch (c) {
case 'a':
.in +5
if (bflg)
.in +5
errflg++;
.in -5
else
.in +5
aflg++;
.in -5
break;
.in -5
case 'b':
.in +5
if (aflg)
.in +5
errflg++;
.in -5
else
.in +5
bproc();
.in -5
break;
.in -5
case 'f':
.in +5
ifile = optarg;
break;
.in -5
case 'o':
.in +5
ofile = optarg;
break;
.in -5
case '?':
.in +5
errflg++;
.in -5
}
.in -5
if (errflg) {
.in +5
fprintf(stderr, "Usage: . . . ");
exit (2);
.in -5
}
for ( ; optind < argc; optind++) {
.in +5
if (access(argv[optind], 4)) {
.in -5
\&.
\&.
\&.
.in -5
}
.eb
.ed
